# 3.2 Code Examples

Suppose we write a  Code file mulstore.c containing the following function definition

```c
long mult2(long, long);

void mulstore(long x, long y, long *desc) {
    long t = mult2(x, y);
    *desc = t;
}
```

To see the assembly code generated by the C compiler, we can use the `-S` option on the command line:

{% hint style="info" %}
linux> gcc -Og -S mulstore.c
{% endhint %}

The assembly-code file contains various declarations, including the following set of lines:

```c
	.section	__TEXT,__text,regular,pure_instructions
	.build_version macos, 11, 0	sdk_version 11, 3
	.globl	_mulstore                       ## -- Begin function mulstore
	.p2align	4, 0x90
_mulstore:                              ## @mulstore
	.cfi_startproc
## %bb.0:
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset %rbp, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register %rbp
	pushq	%rbx
	pushq	%rax
	.cfi_offset %rbx, -24
	movq	%rdx, %rbx
	callq	_mult2
	movq	%rax, (%rbx)
	addq	$8, %rsp
	popq	%rbx
	popq	%rbp
	retq
	.cfi_endproc
                                        ## -- End function
.subsections_via_symbols
```

**Each indented line in the code corresponds to a single machine instruction. **For example, the `pushq` instruction indicates that the contents of register `%rbx` should be pushed onto the program stack. All information about local variable names or data types has been stripped away.\
上述每一行代码都代表了一条机器指令。例如， pushq 指令表示将寄存器 %rdx 中的内容推到程序栈中。所有本地变量名和数据类型信息都被清除。

If we use `-c` command-line option, gcc will both compile and assemble the code&#x20;

{% hint style="info" %}
linux> gcc -Og -c mulstore.c
{% endhint %}

**A key lesson to learn from this is that the program executed by the machine is simply a sequence of bytes encoding a series of instructions.** The machine has very little information about the source code from which these instructions were generated.\
从中得到一个重要信息，即机器执行的程序只是一个字节序列，他是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。

Several features about machine code and its disassembled representation are worth noting:

* x86-64 instructions can range in length from 1 to 15 bytes. The instruction encoding is designed so that commonly used instructions and those with fewer operands require a smaller number of bytes than do less common ones or ones with more operands.
* The instruction format is designed in such a way that from a given starting position, there is a unique decoding of the bytes into machine instructions. For example, only the instruction `pushq %rbx` can start with byte value 53.
* The disassembler determines the assembly code .based purely on the byte sequences in the machine-code file. It does not require access to the source or assembly-code version of the program.
* The disassembly uses a slightly different naming convention for the instructions than does the assembly code generated by GCC. In our example, it has omitted the suffix 'q' from many of the instructions. These suffixes are size designators and can be omitted in most cases, Conversely, the disassembler adds the suffix 'q' to the call and `ret` instructions. Again, these suffixes can safely be omitted.\


其中一些关于机器代码和他的反汇编表示的特征值注意：

* x86-64 的指令长度的从 1 到 15 字节不等。常用的指令以及操作数比较少的指令所需的字节数少，而哪些不太常用或操作数较多的指令所需字节数较多。
* 设计指令的方式是，从否某个给定位置，可以将字节唯一得解码成机器指令。例如，只有指令 `pushq %rbx` 是以字节值 53 开头的。
* 反汇编只是基于机器代码文件中的字节序了来确定汇编代码。它不需要访问程序的源代码或汇编代码
* 反汇编器使用的指令明明规则与 GCC 生成的汇编带代码使用的有些细微差别。在我们的示例中，它省略了很多指令结尾的 ‘q‘。这些后缀是大小指示符，在大多数情况中可以省略。

**链接器的任务之一 就是为函数调用找到匹配的函数的可执行代码的位置。插入这些指令是为了使函数代码变为16字节，使得就存储系统而言，更好地放置下一个代码块。**
